# Функции, рекурсия, алгоритмы.
# Что будет на лекции сегодня
# ? Функции
# ? Модули
# ? Рекурсия
# ? Быстрая сортировка
# ? Сортировка слиянием

# Модули:
# Модульность:
# Вы когда - нибудь задавались вопрос, как например работает функция .append
# Это же точно такая же функция, как и sumNumbers(n), но мы ее нигде не создаем,
# все дело в том что, это функция автоматически срабатывает и чтобы ей
# пользоваться ничего дополнительно писать не надо.
# Представьте себе такую ситуацию, что Вы создаете огромный проект и у Вас
# имеется большое количество функций, к примеру 5 функций работают со
# словарями, 18 со списками и тд. и у каждой функции свой алгоритм, но их
# объединяет работа с одной коллекцией данных. Согласитесь неудобно работать в
# таком большом файле, где около 80 функций, очень легко потеряться и на
# перемотку кода Вы будете терять драгоценное время. Решение данной проблемы
# есть. Давайте будем создавать отдельные файлы, где будут находиться только
# функции, и эти функции при необходимости вызывать из главного файла.

# Модульность:
# 1. function_file.py (Новый Python файл, в котором находятся функция f(x))


def f(x):
    if x == 1:
        return 'Целое'
    elif x == 2.3:
        return 23
    return  # выход из функции


# Модульность:
# 2. working_file.py 
# Чтобы начать взаимодействовать с функцией в файле function_file.py необходимо
# добавить эту возможность к себе в программный код. Сначала мы обращаемся к
# файлу(без расширения)
# С помощью import мы можем вызвать эту функцию в другом скрипте и дальше
# использовать её в новом файле. Можно сократить название функции в рабочем
# файле с помощью команды:
# Alias (псевдоним) — альтернативное имя, которое даётся функции при еt импорте из
# файла.
import function_file
print(function_file.f(1))  # Целое
print(function_file.f(2.3))  # 23
print(function_file.f(28))  # None

# Значения по умолчанию для функции
# В Python можно перемножать строку на число.
# В данной функции есть два аргумента: symbol (символ или число) и count (число, на
# которое умножается первый аргумент).
# Если введены оба аргумента, функция работает без ошибок. Если только символ —
# функция выдает ошибку.


def new_string(symbol, count):
    return symbol * count
    print(new_string('!', 5))  # !!!!!
    print(new_string('!'))  # TypeError missing 1 required ...

# Значения по умолчанию для функции
# Можно указать значение переменной count по умолчанию. Например, если
# значение явно не указано (нет второго аргумента), по умолчанию значение
# переменной count равно трем.


def new_string(symbol, count=3):
    return symbol * count


print(new_string('!', 5))  # !!!!!
print(new_string('!'))  # !!!
print(new_string(4))  # 12

# Возможность передачи неограниченного
# количества аргументов
# ● Можно указать любое количество значений аргумента функции.
# ● Перед аргументом надо поставить * .
# В примере ниже функция работает со строкой, поэтому при введении чисел
# программа выдаёт ошибку:


def concatenatio(*params):
    res = ""
    for item in params:
        res += item
    return res


print(concatenatio('a', 's', 'd', 'w'))  # asdw
print(concatenatio('a', '1'))  # a1
# print(concatenatio(1, 2, 3, 4)) # TypeError: ...
