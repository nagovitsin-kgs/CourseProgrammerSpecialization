# Знакомство с языком Python (лекции)
# Урок 4. Функции высшего порядка, работа с файлами

# Что будет на лекции сегодня
# ● Анонимные, lambda -функции
# ● Функция map
# ● Функция filter
# ● Функция zip
# ● Функция enumerate
# ● Файлы
# ● Модуль os
# ● Модуль shutil

# ● Анонимные, lambda -функции:


# На предыдущей лекции мы с Вами обговорили создание и
# использование функций в Python, но некоторые функции могут
# понадобиться всего раз за всю работу приложения. Как можно
# обойтись без их явного описания? Как сократить подобный код?
def f(x):
    return x ** 2


print(f(2))  # 4
# Функция в примере занимает всего две строчки кода, но в
# дальнейшем размеры описания функций будут увеличиваться. И
# тогда сокращение кода будет актуальным.

# Анонимные, lambda -функции


# Какой тип данных у функции? → < class “function” >
# У функции есть тип, значит мы можем создать переменную типа функции и положить в эту
# переменную какую - то другую функцию.
def f(x):
    return x ** 2


g = f
print(f(4))  # 16
print(g(4))  # 16 
# Теперь в контексте этого приложения g может использоваться точно так же, как и f.
# g — это переменная, которая хранит в себе ссылку на функцию.

# Зачем это может потребоваться?


# Анонимные, lambda -функции
# Есть некая функция calc, которая принимает в качестве аргумента число, а в качестве результата
# возвращает это число + 10:
def calc1(x):
    return x + 10


print(calc1(10))  # 20
# Если мы добавим в код не только сложение, но и умножение, деление и вычитание, внутри
# одного кода будем плодить одинаковую логику.

# Достаточно взять функцию calc, которая будет в качестве аргумента принимать операцию и чтото выдавать.


def calc2(x):
    return x * 10


def math(op, x):
    print(op(x))


math(calc2, 10)  # 100


# Анонимные, lambda -функции
# Попробуем описать ту же логику для функции с двумя переменными.
# op — операция, воспринимаем её как отдельную функцию. В примере это либо сумма (sum), либо
# перемножение(mylt):
def sum(x, y):
    return x + y


def mylt(x, y):
    return x * y


def calc(op, a, b):
    print(op(a, b))


calc(mylt, 4, 5)  # 20


# Анонимные, lambda -функции
# Можно создать псевдоним для функции сложения (f).
def sum(x, y):
    return x + y


def calc(op, a, b):
    print(op(a, b))


f = sum
calc(f, 4, 5)  # 9


# В Python есть механизм, который позволяет превратить подобный вызов во что-то более
# красивое — это lambda.
def sum(x, y):
    return x + y


# ⇔ (равносильно)
sum = lambda x, y: x + y  # это тоже самое, что выше def sum.


# Анонимные, lambda -функции
# Теперь, чтобы вызвать функцию суммы, достаточно просто вызвать sum.
# Также можно пропустить шаг создания переменной sum и сразу вызвать lambda:
def calc(op, a, b):
    print(op(a, b))


calc(lambda x, y: x + y, 4, 5)  # 9

# Итак:
# 1. Сначала мы избавились от классического описания функций.
# 2. Затем научились описывать лямбды, присваивая результат какой - то переменной.
# 3. После избавились от этой переменной, пробрасывая всю лямбду в качестве функции.

# Задача для самостоятельного решения
# 1. В списке хранятся числа. Нужно выбрать только чётные числа и составить список пар
# (число; квадрат числа).
# Пример: 1 2 3 5 8 15 23 38
# Получить: [(2, 4), (8, 64), (38, 1444)]

# Решение:
data = [1, 2, 3, 5, 8, 15, 23, 38]
out = []
for i in data:
    if i % 2 == 0:
        out.append((i, i ** 2))

print(out)


# Как можно сделать этот код лучше, используя lambda? # select - выбирать # where - где
def select(f, col):
    return [f(x) for x in col]  # возвращает x, в которую мы применили f


def where(f, col):
    return [x for x in col if f(x)]  # будет возвращать x, в том случае, если выполнилось условие f(x)


data = [1, 2, 3, 5, 8, 15, 23, 38]
res = select(int, data)
res = where(lambda x: x % 2 == 0, res)  # ф-я lambda будет возвращать в том случае, если будет x%2=0
print(res)  # [2, 8, 38]
res = list(select(lambda x: (x, x ** 2), res))  # будем возвращать кортеж (x, x ** 2), передавать res, т.е
# мы будем вызвать ф-цию select, будем передовать список res и возвращать изменённый кортеж.
print(res)  # [(2, 4), (8, 64), (38, 1444)]

# //////////////////////////////////////////////////////////////////

# ● Функция map: (принимает два аргумента: сама ф-ция и объект)

# Функция map() применяет указанную функцию к каждому элементу итерируемого объекта и
# возвращает итератор с новыми объектами.
# Есть набор данных. Функция map позволяет увеличить каждый объект на 10.
# f(x) => x + 10
# map(f, [1, 2, 3, 4, 5]) выведет все значения +10 # [11, 12, 13, 14, 15]

# Функция map
list_1 = [x for x in range (1, 20)]
list_1 = list(map(lambda x: x + 10, list_1))  # map принимает ф-ю и объект = возвращаем сам объект (в списке)
print(list_1)  # [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]

# Задача: C клавиатуры вводится некий набор чисел, в качестве разделителя используется
# пробел. Этот набор чисел будет считан в качестве строки. Как превратить list строк в list чисел?
# 1. Маленькое отступление, функция строка.split() - убирает все пробелы и создаем список из
# значений строки, пример:
data = '1 2 3 5 8 15 23 38'.split()  # split - преобразует строку в список
print(data)  # ['1', '2', '3', '5', '8', '15', '23', '38']

# 2. Теперь вернемся к задаче. С помощью функции map():
""" data = list(map(int, input().split())) """  # int/str - вывод итерировано, (input().split()) - это ввод/действие/ф-цию - принимает. Выполняет один раз.
""" print(data) """  # ввод: 1 2 3 вывод [1, 2, 3]


# Функция map
# Результат работы map() — это итератор. По итератору можно пробежаться только один раз. Чтобы
# работать несколько раз с одними данными, нужно сохранить данные (например, в виде списка).
# Как можно сделать этот код лучше, используя map()?
# map() позволит избавиться от функции select.
def where(f, col):
    return [x for x in col if f(x)]


data = '1 2 3 5 8 15 23 38'.split()
res = map(int, data)
res = where(lambda x: x % 2 == 0, res)
res = list(map(lambda x: (x, x ** 2), res))
print(res)  # [(2, 4), (8, 64), (38, 1444)]

# ////////////////////////////////////////////////////////////////////

# Функция filter:

# Функция filter() применяет указанную функцию к каждому элементу итерируемого объекта и
# возвращает итератор с теми объектами, для которых функция вернула True.
data = [x for x in range(10)]
res = list(filter(lambda x: x % 2 == 0, data))
print(res)  # [0, 2, 4, 6, 8]
# Как в данном случае работает функция filter()? Все данные, которые находятся внутри проходят
# через функцию, которая указана следующим образом:
# lambda x: x % 2 == 0
# То есть делает проверка на те числа, которые при делении на 2 дают в остатке 0. Тем самым мы
# ищем только четные числа. Действительно преобразовав наши итоговые данные в список, с
# помощью функции list(), мы с Вами можем наблюдать такой красивый результат).

# Функция filter
# Как можно сделать этот код лучше, используя filter()?
# filter() позволит избавиться от функции where, которую мы писали ранее
data = '1 2 3 5 8 15 23 38'.split()
res = map(int, data)
res = filter(lambda x: x % 2 == 0, res)
res = list(map(lambda x: (x, x ** 2), res))
print(res)

# /////////////////////////////////////////////////////////

# Функция zip:

# Функция zip() применяется к набору итерируемых объектов и возвращает итератор с кортежами
# из элементов входных данных
# На выходе получаем набор данных, состоящий из элементов соответствующих
# исходному набору.
# zip([1, 2, 3], ['o', 'д', 'т'], ['f', 's', 't'])
# [(1, 'о', 'f'), (2, 'д', 's'), (3, 'т', 't')]

# Функция zip
# Пример:
users = ['user1', 'user2', 'user3', 'user4', 'user5']
ids = [4, 5, 9, 14, 7]
data = list(zip(users, ids))
print(data)  # [('user1', 4), ('user2', 5), ('user3', 9), ('user4', 14), ('user5', 7)]

# Функция zip () пробегает по минимальному входящему набору:
users = ['user1', 'user2', 'user3', 'user4', 'user5']
ids = [4, 5, 9, 14, 7]
salary = [111, 222, 333]
data = list(zip(users, ids, salary))
print(data)  # [('user1', 4, 111), ('user2', 5, 222), ('user3', 9, 333)]

# ///////////////////////////////////////////////////////////////

# Функция enumerate:

# Функция enumerate() применяется к итерируемому объекту и возвращает новый итератор с
# кортежами из индекса и элементов входных данных.
# Функция enumerate() позволяет пронумеровать набор данных.
users = ['user1', 'user2', 'user3']
data = list(enumerate(users))
print(data)  # [(0, 'user1'), (1, 'user2'), (2, 'user3))]

# //////////////////////////////////////////////////

# Файлы:

# Файлы в текстовом формате используются для:
# ● Хранения данных
# ● Передачи данных в клиент - серверных проектах
# ● Хранения конфигов
# ● Логирования действий

# Что нужно для работы с файлами:
# 1. Завести переменную, которая будет связана с этим текстовым файлом.
# 2. Указать путь к файлу.
# 3. Указать, в каком режиме мы будем работать с файлом.

# Файлы:

# Варианты режима (мод): a, r, w

# a – открытие для добавления данных.
# ○ Позволяет дописывать что-то в имеющийся файл.
# ○ Если вы попробуете дописать что-то в несуществующий файл, то файл будет создан и в него начнется запись.

# r – открытие для чтения данных.
# ○ Позволяет читать данные из файла.
# ○ Если вы попробуете считать данные из файла, которого не существует, программа выдаст ошибку.

# w (writelines) – открытие для записи данных.
# ○ Позволяет записывать данные и создавать файл, если его не существует.

# writelines() - Для записи строк из списка в файл используется метод writelines (). Этот метод записывает строки в файл по очереди, без разделителя. Пример его использования: lines= [" Это первая строка\n", " А вот и вторая\n", " И третья — последняя\n"] with open (" output_2.txt", " w", encoding=" UTF-8") as file_out: file_out.writelines (lines). Содержимое выходного файла: Это первая строка А вот и вторая И третья — последняя.

# Файлы:

# Миксованные режимы:

# 1. w +
# ○ Позволяет открывать файл для записи и читать из него.
# ○ Если файла не существует, он будет создан.

# 2. r +
# ○ Позволяет открывать файл для чтения и дописывать в него.
# ○ Если файла не существует, программа выдаст ошибку.

# Файлы:

# Примеры использования различных режимов в коде:

# 1. Режим a (a – открытие для добавления данных)
"""
colors = ['red', 'green', 'blue']
data = open('file.txt', 'a')  # здесь указываем режим, в котором будем работать
data.writelines(colors)  # разделителей не будет
data.close()
"""
# ● data.close() — используется для закрытия файла, чтобы разорвать подключение файловой
# переменной с файлом на диске.
# ● exit() — позволяет не выполнять код, прописанный после этой команды в скрипте.
# ● В итоге создаётся текстовый файл с текстом внутри: redbluedreen.
# ● При повторном выполнении скрипта redbluedreenredbluedreen — добавление в
# существующий файл, а не перезапись файлов.

# Ещё один способ записи данных в файл: (write - писать), (with - с, в, на, с помощью)
"""
with open('file.txt', 'w') as data:
    data.write('line 1\n')
    data.write('line 2\n')
"""
# 2. Режим r (r – открытие для чтения данных)

# ● Чтение данных из файла:(path -путь), (line - строка)
"""
path = 'file.txt'
data = open(path, 'r')
for line in data:
    print(line)  # выведет что в файле file.txt на экран
data.close()
"""
# Файлы
# 3. Режим w (w – открытие для записи данных)
"""
colors = ['red', 'green', 'blue']
data = open('file.txt', 'w')
data.writelines(colors)  # разделителей не будет
data.close()
"""
# ● В итоге создаётся текстовый файл с текстом внутри: ‘redbluedreen’.
# ● В случае перезаписи новые данные записываются, а старые удаляются.

# //////////////////////////////////////////////////////////////////

# Модуль os:

# Модуль os предоставляет множество функций для работы с операционной системой, причем их
# поведение, как правило, не зависит от ОС, поэтому программы остаются переносимыми.
# Для того, чтобы начать работать с данным модулем необходимо его импортировать в свою
# программу:
# import os
# Познакомимся с базовыми функциями данного модуля:

# ● os.chdir(path) - смена текущей директории.
# (Функция chdir() модуля os изменяет текущий рабочий каталог. Аргумент path может принимать объекты, представляющие путь файловой системы, такие как pathlib.)
import os
os.chdir('C:/Users/79190/PycharmProjects/GB')
# ● os.getcwd() - текущая рабочая директория
# import os
# print(os.getcwd())  # 'C:\Users\79190\PycharmProjects\webproject'

# Модуль os:
# ● os.path - является вложенным модулем в модуль os и реализует некоторые полезные функции для работы с
# путями, такие как:
# ○ os.path.basename(path) - базовое имя пути
# import os
# print(os.path.basename('C:/Users/79190/PycharmProjects/webproject/main.py'))  # 'main.py'
# ● os.path.abspath(path) - возвращает нормализованный абсолютный путь.
# import os
# print(os.path.abspath('main.py'))  # 'C:/Users/79190/PycharmProjects/webproject/main.py'
# Это лишь малая часть возможностей модуля os.

# ///////////////////////////////////////////////////

# Модуль shutil:

# Модуль shutil содержит набор функций высокого уровня для обработки файлов, групп файлов, и папок. В частности,
# доступные здесь функции позволяют копировать, перемещать и удалять файлы и папки. Часто используется вместе
# с модулем os.
# Для того, чтобы начать работать с данным модулем необходимо его импортировать в свою программу:
# import shutil
# Познакомимся с базовыми функциями данного модуля:
# ● shutil.copyfile(src, dst) - копирует содержимое (но не метаданные) файла src в файл dst.
# ● shutil.copy(src, dst) - копирует содержимое файла src в файл или папку dst.
# ● shutil.rmtree(path) - Удаляет текущую директорию и все поддиректории; path должен указывать на
# директорию, а не на символическую ссылку.

# Итоги:

# ● Изучали функции высшего порядка, такие как:
# ○ map
# ○ filter
# ○ zip
# ○ lambda
# ○ enumerate

# ● Научили работать с файлами
# ● Изучили библиотеки для работы с операционной системой и файлами
